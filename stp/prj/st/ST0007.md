---
verblock: "15 Apr 2025:v0.1: Matthew Sinclair - Initial version"
stp_version: 1.0.0
status: WIP
created: 20250415
completed: 
---

# ST0007: Improved CLI and REPL Error Handling

## Summary

Improve error handling in Arca CLI and REPL to address issues where errors bubble up through the command chain without proper handling. Currently, these errors result in uninformative and duplicate error messages, making debugging difficult. This steel thread provides a comprehensive solution with enhanced error reporting, debug mode capability, and consistent error handling across the CLI application.

## Design

### Current Issues

1. **Uninformative Error Messages**: When an unhandled error bubbles up through the command chain, users see only basic error messages without context or debug information.

2. **Duplicate Error Messages**: In some error scenarios, the same error message is displayed twice due to multiple error handling paths.

3. **Inconsistent Error Handling**: The codebase transitions between legacy `{:error, reason}` and newer `{:error, error_type, reason}` formats.

4. **Lost Debug Information**: Exception details are logged but not made available to the user for troubleshooting.

### Proposed Solution

The solution introduces a centralized error handling approach with enhanced error information and an optional debug mode:

1. **Centralized Error Handler Module**: Create `Arca.Cli.ErrorHandler` to standardize error handling across the application.

2. **Enhanced Error Tuples**: Extend error tuples to include debug information such as stack traces and error context.

3. **Debug Mode Command**: Add a new `cli.debug` command to toggle detailed error information for users.

4. **Unified Error Formatting**: Consolidate error formatting logic to eliminate duplicate messages.

5. **Improved Exception Handling**: Preserve stack traces and context when handling exceptions.

### Components

#### 1. ErrorHandler Module

```elixir
defmodule Arca.Cli.ErrorHandler do
  @moduledoc """
  Central module for handling and formatting errors in Arca CLI.
  """
  
  @type error_type :: Arca.Cli.error_type() | Arca.Cli.Command.BaseCommand.error_type()
  
  @typedoc "Debug information attached to errors"
  @type debug_info :: %{
    stack_trace: list(),
    error_location: String.t(),
    original_error: any(),
    timestamp: DateTime.t()
  }
  
  @typedoc "Enhanced error tuple with debug information"
  @type enhanced_error :: {:error, error_type(), String.t(), debug_info() | nil}
  
  @doc """
  Create an enhanced error with debug information.
  """
  @spec create_error(error_type(), String.t(), Keyword.t()) :: enhanced_error()
  def create_error(error_type, reason, opts \\ []) do
    stack_trace = Keyword.get(opts, :stack_trace, nil) || Process.info(self(), :current_stacktrace)
    error_location = Keyword.get(opts, :error_location, nil)
    original_error = Keyword.get(opts, :original_error, nil)
    
    debug_info = %{
      stack_trace: stack_trace,
      error_location: error_location,
      original_error: original_error,
      timestamp: DateTime.utc_now()
    }
    
    {:error, error_type, reason, debug_info}
  end
  
  @doc """
  Format errors for display with optional debug information.
  """
  @spec format_error(enhanced_error() | any(), Keyword.t()) :: String.t()
  def format_error({:error, error_type, reason, debug_info}, opts \\ []) do
    include_debug = Keyword.get(opts, :debug, false)
    
    base_error = "Error (#{error_type}): #{reason}"
    
    if include_debug && debug_info do
      base_error <> "\n" <> format_debug_info(debug_info)
    else
      base_error
    end
  end
  
  # Handle legacy error formats
  def format_error({:error, error_type, reason}, opts), do: format_error({:error, error_type, reason, nil}, opts)
  def format_error({:error, reason}, opts), do: format_error({:error, :unknown_error, reason, nil}, opts)
  
  # Pass through non-error values unchanged
  def format_error(value, _), do: value
  
  defp format_debug_info(debug_info) do
    # Format debug information in a structured, readable way
    [
      "Debug Information:",
      "  Time: #{debug_info.timestamp}",
      if debug_info.error_location, do: "  Location: #{debug_info.error_location}",
      if debug_info.original_error, do: "  Original error: #{inspect(debug_info.original_error)}",
      "  Stack trace:",
      format_stack_trace(debug_info.stack_trace)
    ]
    |> Enum.reject(&is_nil/1)
    |> Enum.join("\n")
  end
  
  defp format_stack_trace(nil), do: "    <not available>"
  defp format_stack_trace(stack_trace) do
    Enum.map_join(stack_trace, "\n", fn {module, function, arity, location} ->
      file = Keyword.get(location, :file, "<unknown>")
      line = Keyword.get(location, :line, "<unknown>")
      "    #{inspect(module)}.#{function}/#{arity} (#{file}:#{line})"
    end)
  end
end
```

#### 2. Debug Mode Command

```elixir
defmodule Arca.Cli.Commands.CliDebugCommand do
  use Arca.Cli.Command.BaseCommand
  
  config :"cli.debug",
    name: "cli.debug",
    about: "Show or toggle debug mode for detailed error information",
    args: [
      toggle: [
        value_name: "on|off",
        help: "Turn debug mode on or off",
        required: false
      ]
    ]
    
  @impl true
  def handle(args, _settings, _optimus) do
    toggle = args.args.toggle
    
    current = Application.get_env(:arca_cli, :debug_mode, false)
    
    case toggle do
      nil ->
        "Debug mode is currently #{if current, do: "ON", else: "OFF"}"
        
      "on" ->
        Application.put_env(:arca_cli, :debug_mode, true)
        "Debug mode is now ON"
        
      "off" ->
        Application.put_env(:arca_cli, :debug_mode, false)
        "Debug mode is now OFF"
        
      _ ->
        {:error, :invalid_argument, "Invalid value '#{toggle}'. Use 'on' or 'off'."}
    end
  end
end
```

#### 3. Enhanced execute_command Function

Update the error handling in the command execution path to capture and preserve error details:

```elixir
@spec execute_command(atom(), map(), map(), term(), module()) ::
        result(String.t() | [String.t()])
def execute_command(cmd, args, settings, optimus, handler) do
  try do
    # Use the centralized help system to check if help should be shown
    if Arca.Cli.Help.should_show_help?(cmd, args, handler) do
      # Show help for this command using the centralized help system
      {:ok, Arca.Cli.Help.show(cmd, args, optimus)}
    else
      # Normal command execution with enhanced error handling
      result = handler.handle(args, settings, optimus)
      
      # Normalize error formats using the central ErrorHandler
      case result do
        {:error, reason} when is_binary(reason) ->
          # Convert legacy error format to enhanced format
          ErrorHandler.create_error(:command_failed, reason, error_location: "#{handler}.handle/3")
        
        {:error, error_type, reason} ->
          # Convert standard error format to enhanced format
          ErrorHandler.create_error(error_type, reason, error_location: "#{handler}.handle/3")
        
        {:error, error_type, reason, _debug_info} = enhanced_error ->
          # Already using enhanced format, pass through
          enhanced_error
        
        other ->
          # All other returns (string, list, etc.) considered success
          {:ok, other}
      end
    end
  rescue
    e ->
      stacktrace = System.stacktrace()
      Logger.error("Error executing command #{cmd}: #{inspect(e)}\n#{Exception.format_stacktrace(stacktrace)}")
      
      # Create enhanced error with exception details
      ErrorHandler.create_error(
        :command_failed,
        "Error executing command #{cmd}: #{Exception.message(e)}",
        original_error: e,
        stack_trace: stacktrace,
        error_location: "execute_command/5"
      )
  end
end
```

#### 4. Updated REPL Error Handling

Modify the REPL error handling to use the centralized formatter:

```elixir
@spec print_error(any()) :: :ok
def print_error(error_message) do
  # Use the central error formatter with debug flag
  debug_enabled = Application.get_env(:arca_cli, :debug_mode, false)
  formatted = Arca.Cli.ErrorHandler.format_error(error_message, debug: debug_enabled)
  
  # Print once without duplicate formatting
  IO.puts(formatted)
  :ok
end
```

## Test Case

A test case demonstrating both the current issue and the solution:

```elixir
defmodule Arca.Cli.Test.CommandErrorTest do
  use ExUnit.Case
  import ExUnit.CaptureIO
  alias Arca.Cli.Repl
  
  # Define a test command that will throw an exception
  defmodule TestErrorCommand do
    use Arca.Cli.Command.BaseCommand
    
    config :test_error,
      name: "test_error",
      about: "Test command that throws an exception"
      
    @impl true
    def handle(_args, _settings, _optimus) do
      # Deliberately throw an exception
      raise "This is a test exception"
    end
  end
  
  # Setup function to register our test command
  setup do
    # Register the command for testing
    original_commands = Application.get_env(:arca_cli, :test_commands, [])
    Application.put_env(:arca_cli, :test_commands, [TestErrorCommand | original_commands])
    
    # Clean up after the test
    on_exit(fn ->
      Application.put_env(:arca_cli, :test_commands, original_commands)
    end)
    
    :ok
  end
  
  test "errors show helpful information and don't duplicate" do
    # Test the CLI mode
    cli_output = capture_io(fn ->
      Arca.Cli.main(["test_error"])
    end)
    
    # Verify output contains error info but not duplicated
    assert cli_output =~ "Error executing command test_error: This is a test exception"
    refute cli_output =~ ~r/Error executing command test_error: This is a test exception.*Error executing command test_error: This is a test exception/s
    
    # Test the REPL mode with debug off
    Application.put_env(:arca_cli, :debug_mode, false)
    repl_output = capture_io(fn ->
      Repl.eval("test_error", %{}, nil)
      |> Repl.print_result()
    end)
    
    # Basic error info is shown
    assert repl_output =~ "Error (command_failed): Error executing command test_error: This is a test exception"
    
    # Test the REPL mode with debug on
    Application.put_env(:arca_cli, :debug_mode, true)
    debug_output = capture_io(fn ->
      Repl.eval("test_error", %{}, nil)
      |> Repl.print_result()
    end)
    
    # Detailed error info is shown
    assert debug_output =~ "Error (command_failed): Error executing command test_error: This is a test exception"
    assert debug_output =~ "Debug Information:"
    assert debug_output =~ "Stack trace:"
  end
end
```

## Benefits

1. **Improved User Experience**: Users get more informative and non-duplicate error messages.
2. **Enhanced Debugging**: Debug mode provides detailed error information on demand.
3. **Consistent Error Handling**: Standardized error formatting and display across the application.
4. **Better Error Context**: Stack traces and error locations help with troubleshooting.
5. **Backward Compatibility**: Support for both legacy and new error formats.

## Documentation

- Updated [User Guide](/stp/usr/user_guide.md) with information about the debug mode and improved error messages
- Updated [Reference Guide](/stp/usr/reference_guide.md) with details about the new error handling framework
- Updated [Deployment Guide](/stp/usr/deployment_guide.md) with information about the new debug capability